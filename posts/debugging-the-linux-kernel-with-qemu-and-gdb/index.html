<!doctype html><html lang=en><head><title>Debugging the Linux Kernel with QEMU and GDB · yuankun@net: ~$</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yuankun Zhang"><meta name=description content="In the previous article, we explored how to run a raw Linux kernel in QEMU. Another fascinating feature that QEMU provides is to initiate a GDB server. An external GDB debugger can then connect to it. This means that we can suspend the kernel running at any point of the kernel startup. By leveraging this feature, we can construct an efficient environment to debug system kernels and firmware. In this guide, we will explore the process of using this feature to debug the Linux kernel."><meta name=keywords content="code,read,life"><meta name=twitter:card content="summary"><meta name=twitter:title content="Debugging the Linux Kernel with QEMU and GDB"><meta name=twitter:description content="In the previous article, we explored how to run a raw Linux kernel in QEMU. Another fascinating feature that QEMU provides is to initiate a GDB server. An external GDB debugger can then connect to it. This means that we can suspend the kernel running at any point of the kernel startup. By leveraging this feature, we can construct an efficient environment to debug system kernels and firmware. In this guide, we will explore the process of using this feature to debug the Linux kernel."><meta property="og:title" content="Debugging the Linux Kernel with QEMU and GDB"><meta property="og:description" content="In the previous article, we explored how to run a raw Linux kernel in QEMU. Another fascinating feature that QEMU provides is to initiate a GDB server. An external GDB debugger can then connect to it. This means that we can suspend the kernel running at any point of the kernel startup. By leveraging this feature, we can construct an efficient environment to debug system kernels and firmware. In this guide, we will explore the process of using this feature to debug the Linux kernel."><meta property="og:type" content="article"><meta property="og:url" content="https://yuankun.me/posts/debugging-the-linux-kernel-with-qemu-and-gdb/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-20T09:31:33+08:00"><meta property="article:modified_time" content="2020-03-20T09:31:33+08:00"><link rel=canonical href=https://yuankun.me/posts/debugging-the-linux-kernel-with-qemu-and-gdb/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.85656f585fe601450b123ec7c9a997f8488faf7f9e2c81913580c9e2f8c72f82.css integrity="sha256-hWVvWF/mAUULEj7HyamX+EiPr3+eLIGRNYDJ4vjHL4I=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.75de71d89fefe379cc001b6f6435f9b06dad86408428254718b48a73ea6d9e5e.css integrity="sha256-dd5x2J/v43nMABtvZDX5sG2thkCEKCVHGLSKc+ptnl4=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>yuankun@net: ~$</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://yuankun.me/posts/debugging-the-linux-kernel-with-qemu-and-gdb/>Debugging the Linux Kernel with QEMU and GDB</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-03-20T09:31:33+08:00>March 20, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/linux/>linux</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/qemu/>qemu</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/gdb/>gdb</a></span></div></div></header><div class=post-content><p>In the <a href=/posts/running-the-raw-linux-kernel-in-qemu/>previous article</a>, we explored how to run a raw Linux kernel in QEMU. Another fascinating feature that QEMU provides is to initiate a GDB server. An external GDB debugger can then connect to it. This means that we can suspend the kernel running at any point of the kernel startup. By leveraging this feature, we can construct an efficient environment to debug system kernels and firmware. In this guide, we will explore the process of using this feature to debug the Linux kernel.</p><h2 id=compiling-the-kernel-with-debugging-information>Compiling the Kernel with Debugging Information
<a class=heading-link href=#compiling-the-kernel-with-debugging-information><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The first step involves preparing a kernel embedded with debugging information. To achieve this, we enable the relavent kernel configurations:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cd linux-source/
</span></span><span style=display:flex><span>$ make menuconfig
</span></span></code></pre></div><p>Next, navigate to <code>Kernel hacking > Compile-time checks and compiler options</code>. Here, enable the following two options:</p><ul><li>Compile the kernel with debug info</li><li>Provide GDB scripts for kernel debugging</li></ul><p><img src=/img/provide-gdb-scripts-for-kernel-debugging.png alt="Provide GDB scripts for kernel debugging"></p><p>Once we&rsquo;ve made these changes, save the new configuration and initiate the kernel compilation by executing <code>make -j${nproc}</code>. Following the compilation, we are interested in the two newly created files:</p><ul><li>vmlinux: A statically linked executable file format of the Linux Kernel, packed with all debugging information.</li><li>scripts/gdb/vmlinux-gdb.py: The GDB script used for kernel debugging.</li></ul><p>To ensure that the GDB script loads every time we initiate the GDB Debugger, let&rsquo;s add it to the GDB init file:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ echo <span style=color:#a5d6ff>&#34;add-auto-load-safe-path `pwd`/scripts/gdb/vmlinux-gdb.py&#34;</span> &gt;&gt; ~/.gdbinit
</span></span></code></pre></div><h2 id=initiating-debugging-session>Initiating Debugging Session
<a class=heading-link href=#initiating-debugging-session><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>When debugging, QEMU provides two significant options:</p><ul><li>The <code>-S</code> option stops the CPU at the startup, allowing the debugger to connect and facilitating debugging from the start.</li><li>The <code>-s</code> option initiates a GDB Server on port 1234. Consequently, we can connect the GDB Debugger we can connect to it using <code>target remote :1234</code>.</li></ul><p>Now let&rsquo;s boot the kernel with these options:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ qemu-system-x86_64 <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -S <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -s <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -enable-kvm <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -kernel bzImage <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -smp <span style=color:#79c0ff>cores</span><span style=color:#ff7b72;font-weight:700>=</span>1,threads<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>2</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -m <span style=color:#a5d6ff>1024</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -append <span style=color:#a5d6ff>&#34;console=ttyS0 nokaslr selinux=0 debug&#34;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -initrd initramfs.img <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -serial stdio <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -display none
</span></span></code></pre></div><p>At this stage, the process remains on hold, since we instructed QEMU to pause for the debugger by using the <code>-S</code> option.</p><p>Open another terminal window and start the GDB Debugger, then connect it to QEMU:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ gdb vmlinux
</span></span><span style=display:flex><span>Type <span style=color:#a5d6ff>&#34;apropos word&#34;</span> to search <span style=color:#ff7b72>for</span> commands related to <span style=color:#a5d6ff>&#34;word&#34;</span>...
</span></span><span style=display:flex><span>Reading symbols from vmlinux...
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>(</span>gdb<span style=color:#ff7b72;font-weight:700>)</span> target remote :1234
</span></span><span style=display:flex><span>Remote debugging using :1234
</span></span><span style=display:flex><span>0x000000000000fff0 in exception_stacks <span style=color:#ff7b72;font-weight:700>()</span>
</span></span></code></pre></div><p>Now we can set breakpoints and track the kernel&rsquo;s executing as if it were just a normal user process:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>(</span>gdb<span style=color:#ff7b72;font-weight:700>)</span> b start_kernel
</span></span><span style=display:flex><span>Note: breakpoints <span style=color:#a5d6ff>1</span> and <span style=color:#a5d6ff>2</span> also set at pc 0xffffffff829e0aa8.
</span></span><span style=display:flex><span>Breakpoint <span style=color:#a5d6ff>3</span> at 0xffffffff829e0aa8: file init/main.c, line 786.
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>(</span>gdb<span style=color:#ff7b72;font-weight:700>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread <span style=color:#a5d6ff>1</span> hit Breakpoint 1, start_kernel <span style=color:#ff7b72;font-weight:700>()</span> at init/main.c:786
</span></span><span style=display:flex><span><span style=color:#a5d6ff>786</span>     <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=references>References
<a class=heading-link href=#references><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li><a href=https://en.wikibooks.org/wiki/QEMU/Debugging_with_QEMU class=external-link target=_blank rel=noopener>Debugging with QEMU</a></li></ul></div><footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("colorscheme");getTheme=getTheme??"github-light";let theme=getTheme==="dark"?"github-dark":"github-light",s=document.createElement("script");s.src="https://utteranc.es/client.js",s.setAttribute("repo","yuankunzhang/blog"),s.setAttribute("issue-term","pathname"),s.setAttribute("theme",theme),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
Yuankun Zhang
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZXQSK4ST20"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZXQSK4ST20",{anonymize_ip:!1})}</script></body></html>