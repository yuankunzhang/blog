<!doctype html><html lang=en><head><title>Smallest Root Filesystem for Linux · yuankun@net: ~$</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yuankun Zhang"><meta name=description content="The Linux kernel works hand in hand with what is called the root filesystem. This is the filesystem which will be mounted to the root directory and where the user space applications are located. How tiny can a root filesystem be, while still remaining functional? By functional, I mean it is capable of letting the kernel finish its booting process and pass control to user space without causing a kernel panic."><meta name=keywords content="code,read,life"><meta name=twitter:card content="summary"><meta name=twitter:title content="Smallest Root Filesystem for Linux"><meta name=twitter:description content="The Linux kernel works hand in hand with what is called the root filesystem. This is the filesystem which will be mounted to the root directory and where the user space applications are located. How tiny can a root filesystem be, while still remaining functional? By functional, I mean it is capable of letting the kernel finish its booting process and pass control to user space without causing a kernel panic."><meta property="og:title" content="Smallest Root Filesystem for Linux"><meta property="og:description" content="The Linux kernel works hand in hand with what is called the root filesystem. This is the filesystem which will be mounted to the root directory and where the user space applications are located. How tiny can a root filesystem be, while still remaining functional? By functional, I mean it is capable of letting the kernel finish its booting process and pass control to user space without causing a kernel panic."><meta property="og:type" content="article"><meta property="og:url" content="https://yuankun.me/posts/smallest-root-filesystem-for-linux/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-22T19:40:33+08:00"><meta property="article:modified_time" content="2020-05-22T19:40:33+08:00"><link rel=canonical href=https://yuankun.me/posts/smallest-root-filesystem-for-linux/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.85656f585fe601450b123ec7c9a997f8488faf7f9e2c81913580c9e2f8c72f82.css integrity="sha256-hWVvWF/mAUULEj7HyamX+EiPr3+eLIGRNYDJ4vjHL4I=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.75de71d89fefe379cc001b6f6435f9b06dad86408428254718b48a73ea6d9e5e.css integrity="sha256-dd5x2J/v43nMABtvZDX5sG2thkCEKCVHGLSKc+ptnl4=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>yuankun@net: ~$</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://yuankun.me/posts/smallest-root-filesystem-for-linux/>Smallest Root Filesystem for Linux</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-05-22T19:40:33+08:00>May 22, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
4-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/linux/>linux</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/rootfs/>rootfs</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/init/>init</a></span></div></div></header><div class=post-content><p>The Linux kernel works hand in hand with what is called the root filesystem. This is the filesystem which will be mounted to the root directory and where the user space applications are located. How tiny can a root filesystem be, while still remaining functional? By functional, I mean it is capable of letting the kernel finish its booting process and pass control to user space without causing a kernel panic.</p><p>In a previous post, <a href=/posts/running-the-raw-linux-kernel-in-qemu>Running the Raw Linux Kernel in QEMU</a>, we discussed that many Linux distributions make use of two kinds of root filesystems: the initial RAM-based root filesystem and the real root filesystem. The former serves a purpose to decrypt, mount, and run the latter. In another post, <a href=debugging-the-linux-kernel-with-qemu-and-gdb>Debugging the Linux Kernel with QEMU and GDB</a>, we used only the initial root filesystem without providing a real one. What happens if we remove the initial root filesystem from the qemu command as well? The kernel will panic when attempting to mount the root filesystem.</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ qemu-system-x86_64 <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -enable-kvm <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -kernel bzImage <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -append <span style=color:#a5d6ff>&#34;console=ttyS0 nokaslr selinux=0 debug&#34;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -serial stdio <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -display none
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.366676<span style=color:#ff7b72;font-weight:700>]</span> Call Trace:
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.366765<span style=color:#ff7b72;font-weight:700>]</span>  &lt;TASK&gt;
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.366946<span style=color:#ff7b72;font-weight:700>]</span>  dump_stack_lvl+0x4a/0x80
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.367210<span style=color:#ff7b72;font-weight:700>]</span>  panic+0x185/0x340
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.367295<span style=color:#ff7b72;font-weight:700>]</span>  mount_block_root+0x299/0x2a0
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.367393<span style=color:#ff7b72;font-weight:700>]</span>  prepare_namespace+0xf0/0x170
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.367493<span style=color:#ff7b72;font-weight:700>]</span>  kernel_init_freeable+0x38c/0x3f0
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.367596<span style=color:#ff7b72;font-weight:700>]</span>  ? __pfx_kernel_init+0x10/0x10
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.367697<span style=color:#ff7b72;font-weight:700>]</span>  kernel_init+0x15/0x1b0
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.367776<span style=color:#ff7b72;font-weight:700>]</span>  ret_from_fork+0x2c/0x50
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.367914<span style=color:#ff7b72;font-weight:700>]</span>  &lt;/TASK&gt;
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.368224<span style=color:#ff7b72;font-weight:700>]</span> Kernel Offset: disabled
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>   10.368500<span style=color:#ff7b72;font-weight:700>]</span> ---<span style=color:#ff7b72;font-weight:700>[</span> end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block<span style=color:#ff7b72;font-weight:700>(</span>0,0<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>]</span>---
</span></span></code></pre></div><p>Consequently, we must provide a root filesystem and tell the kernel where to locate it. Once the kernel finds and mounts the root filesystem, it attempts to launch the first user space process (the &ldquo;init&rdquo; process) by executing a file found on this root filesystem. There are three ways for the kernel to find the file:</p><ol><li>Initially, it tries to use the <code>init=</code> kernel parameter specified at boot time.</li><li>if the parameter is not set, the kernel then tries to use the value of the <code>CONFIG_DEFAULT_INIT</code> kernel build option, if it was present during the kernel build.</li><li>If all these fail, the kernel tries to find the file in a list of fallback locations. This list includes <code>/sbin/init</code>, <code>/etc/init</code>, <code>/bin/init</code>, and <code>/bin/sh</code>. If still unsuccessful, the kernel panics.</li></ol><p>Here is the kernel code that handles the launch of the init process.</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/* In file init/main.c */</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>static</span> <span style=color:#ff7b72>int</span> __ref <span style=color:#d2a8ff;font-weight:700>kernel_init</span>(<span style=color:#ff7b72>void</span> <span style=color:#ff7b72;font-weight:700>*</span>unused)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>/* ... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>	 * We try each of these until one succeeds.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>	 *
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>	 * The Bourne shell can be used instead of init if we are
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>	 * trying to recover a really broken machine.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>if</span> (execute_command) {
</span></span><span style=display:flex><span>		ret <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>run_init_process</span>(execute_command);
</span></span><span style=display:flex><span>		<span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span>ret)
</span></span><span style=display:flex><span>			<span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>		<span style=color:#d2a8ff;font-weight:700>panic</span>(<span style=color:#a5d6ff>&#34;Requested init %s failed (error %d).&#34;</span>,
</span></span><span style=display:flex><span>		      execute_command, ret);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>if</span> (CONFIG_DEFAULT_INIT[<span style=color:#a5d6ff>0</span>] <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#a5d6ff>&#39;\0&#39;</span>) {
</span></span><span style=display:flex><span>		ret <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>run_init_process</span>(CONFIG_DEFAULT_INIT);
</span></span><span style=display:flex><span>		<span style=color:#ff7b72>if</span> (ret)
</span></span><span style=display:flex><span>			<span style=color:#d2a8ff;font-weight:700>pr_err</span>(<span style=color:#a5d6ff>&#34;Default init %s failed (error %d)</span><span style=color:#79c0ff>\n</span><span style=color:#a5d6ff>&#34;</span>,
</span></span><span style=display:flex><span>			       CONFIG_DEFAULT_INIT, ret);
</span></span><span style=display:flex><span>		<span style=color:#ff7b72>else</span>
</span></span><span style=display:flex><span>			<span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>if</span> (<span style=color:#ff7b72;font-weight:700>!</span><span style=color:#d2a8ff;font-weight:700>try_to_run_init_process</span>(<span style=color:#a5d6ff>&#34;/sbin/init&#34;</span>) <span style=color:#ff7b72;font-weight:700>||</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72;font-weight:700>!</span><span style=color:#d2a8ff;font-weight:700>try_to_run_init_process</span>(<span style=color:#a5d6ff>&#34;/etc/init&#34;</span>) <span style=color:#ff7b72;font-weight:700>||</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72;font-weight:700>!</span><span style=color:#d2a8ff;font-weight:700>try_to_run_init_process</span>(<span style=color:#a5d6ff>&#34;/bin/init&#34;</span>) <span style=color:#ff7b72;font-weight:700>||</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72;font-weight:700>!</span><span style=color:#d2a8ff;font-weight:700>try_to_run_init_process</span>(<span style=color:#a5d6ff>&#34;/bin/sh&#34;</span>))
</span></span><span style=display:flex><span>		<span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#d2a8ff;font-weight:700>panic</span>(<span style=color:#a5d6ff>&#34;No working init found.  Try passing init= option to kernel. &#34;</span>
</span></span><span style=display:flex><span>	      <span style=color:#a5d6ff>&#34;See Linux Documentation/admin-guide/init.rst for guidance.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The concept is straightforward: we just need to place an executable binary under the path <code>/sbin/init</code> of the root filesystem, and the kernel will find it and launch it. Here&rsquo;s a simple such program, it starts an infinite loop to echo whatever the user types on the console. Note that this program must be compiled using the <code>-static</code> GCC option.</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * filename: init.c
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * compile: cc -o init -static init.c
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#include</span> <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8b949e;font-weight:700;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>main</span>(<span style=color:#ff7b72>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>size_t</span> n <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>char</span> <span style=color:#ff7b72;font-weight:700>*</span>line <span style=color:#ff7b72;font-weight:700>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>while</span> (<span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>fputs</span>(<span style=color:#a5d6ff>&#34;[minroot] $ &#34;</span>, stdout);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> (<span style=color:#d2a8ff;font-weight:700>getline</span>(<span style=color:#ff7b72;font-weight:700>&amp;</span>line, <span style=color:#ff7b72;font-weight:700>&amp;</span>n, stdin) <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>)
</span></span><span style=display:flex><span>      <span style=color:#d2a8ff;font-weight:700>fputs</span>(line, stdout);
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>else</span>
</span></span><span style=display:flex><span>      <span style=color:#d2a8ff;font-weight:700>clearerr</span>(stdin);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can construct the root filesystem:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Create an image file and format it.</span>
</span></span><span style=display:flex><span>truncate -s1M minroot
</span></span><span style=display:flex><span>mkfs.ext2 minroot
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Mount the image as a loopback device,</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># and copy over our init executable.</span>
</span></span><span style=display:flex><span>sudo mount -oloop minroot /mnt
</span></span><span style=display:flex><span>sudo mkdir /mnt/sbin
</span></span><span style=display:flex><span>sudo cc -o /mnt/sbin/init -static init.c
</span></span><span style=display:flex><span>sudo umount /mnt
</span></span></code></pre></div><p>Let&rsquo;s repeat the above qemu command, but this time, we provide the root filesystem image to it as a hard drive.</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ qemu-system-x86_64 <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -enable-kvm <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -kernel bzImage <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -hda minroot <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -append <span style=color:#a5d6ff>&#34;root=/dev/sda console=ttyS0 nokaslr selinux=0 debug&#34;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -serial stdio <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -display none
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.753474<span style=color:#ff7b72;font-weight:700>]</span> VFS: Mounted root <span style=color:#ff7b72;font-weight:700>(</span>ext2 filesystem<span style=color:#ff7b72;font-weight:700>)</span> readonly on device 8:0.
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.755672<span style=color:#ff7b72;font-weight:700>]</span> devtmpfs: error mounting -2
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.809455<span style=color:#ff7b72;font-weight:700>]</span> Freeing unused kernel image <span style=color:#ff7b72;font-weight:700>(</span>initmem<span style=color:#ff7b72;font-weight:700>)</span> memory: 4616K
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.809906<span style=color:#ff7b72;font-weight:700>]</span> Write protecting the kernel read-only data: 26624k
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.814056<span style=color:#ff7b72;font-weight:700>]</span> Freeing unused kernel image <span style=color:#ff7b72;font-weight:700>(</span>rodata/data gap<span style=color:#ff7b72;font-weight:700>)</span> memory: 1664K
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.961361<span style=color:#ff7b72;font-weight:700>]</span> x86/mm: Checked W+X mappings: passed, no W+X pages found.
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.961949<span style=color:#ff7b72;font-weight:700>]</span> Run /sbin/init as init process
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.962048<span style=color:#ff7b72;font-weight:700>]</span>   with arguments:
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.962118<span style=color:#ff7b72;font-weight:700>]</span>     /sbin/init
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.962203<span style=color:#ff7b72;font-weight:700>]</span>     nokaslr
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.962266<span style=color:#ff7b72;font-weight:700>]</span>   with environment:
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.962422<span style=color:#ff7b72;font-weight:700>]</span>     <span style=color:#79c0ff>HOME</span><span style=color:#ff7b72;font-weight:700>=</span>/
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>    9.962492<span style=color:#ff7b72;font-weight:700>]</span>     <span style=color:#79c0ff>TERM</span><span style=color:#ff7b72;font-weight:700>=</span>linux
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>[</span>minroot<span style=color:#ff7b72;font-weight:700>]</span> $
</span></span></code></pre></div><p>We&rsquo;ve successfully reached the infinite echoing loop. Although our init process is not doing anything practically useful, it demonstrates how the kernel passes the torch to user space. In front of the init process is the vast and intriguing universe of user space.</p><p>I&rsquo;ll end this post with a question: What will happen if the init process exits/aborts?</p></div><footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("colorscheme");getTheme=getTheme??"github-light";let theme=getTheme==="dark"?"github-dark":"github-light",s=document.createElement("script");s.src="https://utteranc.es/client.js",s.setAttribute("repo","yuankunzhang/blog"),s.setAttribute("issue-term","pathname"),s.setAttribute("theme",theme),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2023
Yuankun Zhang
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZXQSK4ST20"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZXQSK4ST20",{anonymize_ip:!1})}</script></body></html>