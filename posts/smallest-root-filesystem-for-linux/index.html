<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Smallest Root Filesystem for Linux - yuankun@net: ~$</title><meta name=Description content="Always do what you're afraid to do"><meta property="og:title" content="Smallest Root Filesystem for Linux"><meta property="og:description" content="The Linux kernel works hand in hand with what is called the root filesystem. This is the filesystem which will be mounted to the root directory and where the user space applications are located. How tiny can a root filesystem be, while still remaining functional? By functional, I mean it is capable of letting the kernel finish its booting process and pass control to user space without causing a kernel panic."><meta property="og:type" content="article"><meta property="og:url" content="https://yuankun.me/posts/smallest-root-filesystem-for-linux/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-22T19:40:33+08:00"><meta property="article:modified_time" content="2020-05-22T19:40:33+08:00"><meta property="og:site_name" content="yuankun@net: ~$"><meta name=twitter:card content="summary"><meta name=twitter:title content="Smallest Root Filesystem for Linux"><meta name=twitter:description content="The Linux kernel works hand in hand with what is called the root filesystem. This is the filesystem which will be mounted to the root directory and where the user space applications are located. How tiny can a root filesystem be, while still remaining functional? By functional, I mean it is capable of letting the kernel finish its booting process and pass control to user space without causing a kernel panic."><meta name=application-name content="yuankun@net: ~$"><meta name=apple-mobile-web-app-title content="yuankun@net: ~$"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://yuankun.me/posts/smallest-root-filesystem-for-linux/><link rel=prev href=https://yuankun.me/posts/a-terraform-module-to-list-google-cloud-service-agents/><link rel=next href=https://yuankun.me/posts/home-server-setup/><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Smallest Root Filesystem for Linux","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/yuankun.me\/posts\/smallest-root-filesystem-for-linux\/"},"genre":"posts","keywords":"linux, rootfs, init","wordcount":845,"url":"https:\/\/yuankun.me\/posts\/smallest-root-filesystem-for-linux\/","datePublished":"2020-05-22T19:40:33+08:00","dateModified":"2020-05-22T19:40:33+08:00","publisher":{"@type":"Organization","name":"yuankun"},"author":{"@type":"Person","name":"yuankun"},"description":""}</script><script src=//instant.page/5.2.0 defer type=module integrity=sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z></script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else""==="light"||""==="dark"||""==="black"?(setTheme(""),saveTheme("")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="yuankun@net: ~$">yuankun@net: ~$</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Blog </a><a class=menu-item href=/about/>About </a><a class=menu-item href=/syscall64/>Linux x64 Syscalls </a><a class=menu-item href=/syscall32/>Linux x86 Syscalls </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="yuankun@net: ~$">yuankun@net: ~$</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Blog</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=/syscall64/ title>Linux x64 Syscalls</a><a class=menu-item href=/syscall32/ title>Linux x86 Syscalls</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","false")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Smallest Root Filesystem for Linux</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class="author fas fa-user-circle fa-fw"></span><a href=/ title=Author rel=author class=author>yuankun</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2020-05-22>2020-05-22</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2020-05-22>2020-05-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;845 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;4 minutes&nbsp;</div></div><div class=content id=content><p>The Linux kernel works hand in hand with what is called the root filesystem. This is the filesystem which will be mounted to the root directory and where the user space applications are located. How tiny can a root filesystem be, while still remaining functional? By functional, I mean it is capable of letting the kernel finish its booting process and pass control to user space without causing a kernel panic.</p><p>In a previous post, <a href=/posts/running-the-raw-linux-kernel-in-qemu rel>Running the Raw Linux Kernel in QEMU</a>, we discussed that many Linux distributions make use of two kinds of root filesystems: the initial RAM-based root filesystem and the real root filesystem. The former serves a purpose to decrypt, mount, and run the latter. In another post, <a href=debugging-the-linux-kernel-with-qemu-and-gdb rel>Debugging the Linux Kernel with QEMU and GDB</a>, we used only the initial root filesystem without providing a real one. What happens if we remove the initial root filesystem from the qemu command as well? The kernel will panic when attempting to mount the root filesystem.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ qemu-system-x86_64 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -enable-kvm <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -kernel bzImage <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -append <span class=s2>&#34;console=ttyS0 nokaslr selinux=0 debug&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -serial stdio <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -display none
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=o>[</span>   10.366676<span class=o>]</span> Call Trace:
</span></span><span class=line><span class=cl><span class=o>[</span>   10.366765<span class=o>]</span>  &lt;TASK&gt;
</span></span><span class=line><span class=cl><span class=o>[</span>   10.366946<span class=o>]</span>  dump_stack_lvl+0x4a/0x80
</span></span><span class=line><span class=cl><span class=o>[</span>   10.367210<span class=o>]</span>  panic+0x185/0x340
</span></span><span class=line><span class=cl><span class=o>[</span>   10.367295<span class=o>]</span>  mount_block_root+0x299/0x2a0
</span></span><span class=line><span class=cl><span class=o>[</span>   10.367393<span class=o>]</span>  prepare_namespace+0xf0/0x170
</span></span><span class=line><span class=cl><span class=o>[</span>   10.367493<span class=o>]</span>  kernel_init_freeable+0x38c/0x3f0
</span></span><span class=line><span class=cl><span class=o>[</span>   10.367596<span class=o>]</span>  ? __pfx_kernel_init+0x10/0x10
</span></span><span class=line><span class=cl><span class=o>[</span>   10.367697<span class=o>]</span>  kernel_init+0x15/0x1b0
</span></span><span class=line><span class=cl><span class=o>[</span>   10.367776<span class=o>]</span>  ret_from_fork+0x2c/0x50
</span></span><span class=line><span class=cl><span class=o>[</span>   10.367914<span class=o>]</span>  &lt;/TASK&gt;
</span></span><span class=line><span class=cl><span class=o>[</span>   10.368224<span class=o>]</span> Kernel Offset: disabled
</span></span><span class=line><span class=cl><span class=o>[</span>   10.368500<span class=o>]</span> ---<span class=o>[</span> end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block<span class=o>(</span>0,0<span class=o>)</span> <span class=o>]</span>---
</span></span></code></pre></div><p>Consequently, we must provide a root filesystem and tell the kernel where to locate it. Once the kernel finds and mounts the root filesystem, it attempts to launch the first user space process (the &ldquo;init&rdquo; process) by executing a file found on this root filesystem. There are three ways for the kernel to find the file:</p><ol><li>Initially, it tries to use the <code>init=</code> kernel parameter specified at boot time.</li><li>if the parameter is not set, the kernel then tries to use the value of the <code>CONFIG_DEFAULT_INIT</code> kernel build option, if it was present during the kernel build.</li><li>If all these fail, the kernel tries to find the file in a list of fallback locations. This list includes <code>/sbin/init</code>, <code>/etc/init</code>, <code>/bin/init</code>, and <code>/bin/sh</code>. If still unsuccessful, the kernel panics.</li></ol><p>Here is the kernel code that handles the launch of the init process.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* In file init/main.c */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__ref</span> <span class=nf>kernel_init</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>unused</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* ... */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	 * We try each of these until one succeeds.
</span></span></span><span class=line><span class=cl><span class=cm>	 *
</span></span></span><span class=line><span class=cl><span class=cm>	 * The Bourne shell can be used instead of init if we are
</span></span></span><span class=line><span class=cl><span class=cm>	 * trying to recover a really broken machine.
</span></span></span><span class=line><span class=cl><span class=cm>	 */</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>execute_command</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>ret</span> <span class=o>=</span> <span class=nf>run_init_process</span><span class=p>(</span><span class=n>execute_command</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=nf>panic</span><span class=p>(</span><span class=s>&#34;Requested init %s failed (error %d).&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		      <span class=n>execute_command</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>CONFIG_DEFAULT_INIT</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>ret</span> <span class=o>=</span> <span class=nf>run_init_process</span><span class=p>(</span><span class=n>CONFIG_DEFAULT_INIT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>pr_err</span><span class=p>(</span><span class=s>&#34;Default init %s failed (error %d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			       <span class=n>CONFIG_DEFAULT_INIT</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/sbin/init&#34;</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>	    <span class=o>!</span><span class=nf>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/etc/init&#34;</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>	    <span class=o>!</span><span class=nf>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/bin/init&#34;</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>	    <span class=o>!</span><span class=nf>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>panic</span><span class=p>(</span><span class=s>&#34;No working init found.  Try passing init= option to kernel. &#34;</span>
</span></span><span class=line><span class=cl>	      <span class=s>&#34;See Linux Documentation/admin-guide/init.rst for guidance.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The concept is straightforward: we just need to place an executable binary under the path <code>/sbin/init</code> of the root filesystem, and the kernel will find it and launch it. Here&rsquo;s a simple such program, it starts an infinite loop to echo whatever the user types on the console. Note that this program must be compiled using the <code>-static</code> GCC option.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * filename: init.c
</span></span></span><span class=line><span class=cl><span class=cm> * compile: cc -o init -static init.c
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>line</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fputs</span><span class=p>(</span><span class=s>&#34;[minroot] $ &#34;</span><span class=p>,</span> <span class=n>stdout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>getline</span><span class=p>(</span><span class=o>&amp;</span><span class=n>line</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>,</span> <span class=n>stdin</span><span class=p>)</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>fputs</span><span class=p>(</span><span class=n>line</span><span class=p>,</span> <span class=n>stdout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=nf>clearerr</span><span class=p>(</span><span class=n>stdin</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now we can construct the root filesystem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Create an image file and format it.</span>
</span></span><span class=line><span class=cl>truncate -s1M minroot
</span></span><span class=line><span class=cl>mkfs.ext2 minroot
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Mount the image as a loopback device,</span>
</span></span><span class=line><span class=cl><span class=c1># and copy over our init executable.</span>
</span></span><span class=line><span class=cl>sudo mount -oloop minroot /mnt
</span></span><span class=line><span class=cl>sudo mkdir /mnt/sbin
</span></span><span class=line><span class=cl>sudo cc -o /mnt/sbin/init -static init.c
</span></span><span class=line><span class=cl>sudo umount /mnt
</span></span></code></pre></div><p>Let&rsquo;s repeat the above qemu command, but this time, we provide the root filesystem image to it as a hard drive.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ qemu-system-x86_64 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -enable-kvm <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -kernel bzImage <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -hda minroot <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -append <span class=s2>&#34;root=/dev/sda console=ttyS0 nokaslr selinux=0 debug&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -serial stdio <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -display none
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=o>[</span>    9.753474<span class=o>]</span> VFS: Mounted root <span class=o>(</span>ext2 filesystem<span class=o>)</span> <span class=nb>readonly</span> on device 8:0.
</span></span><span class=line><span class=cl><span class=o>[</span>    9.755672<span class=o>]</span> devtmpfs: error mounting -2
</span></span><span class=line><span class=cl><span class=o>[</span>    9.809455<span class=o>]</span> Freeing unused kernel image <span class=o>(</span>initmem<span class=o>)</span> memory: 4616K
</span></span><span class=line><span class=cl><span class=o>[</span>    9.809906<span class=o>]</span> Write protecting the kernel read-only data: 26624k
</span></span><span class=line><span class=cl><span class=o>[</span>    9.814056<span class=o>]</span> Freeing unused kernel image <span class=o>(</span>rodata/data gap<span class=o>)</span> memory: 1664K
</span></span><span class=line><span class=cl><span class=o>[</span>    9.961361<span class=o>]</span> x86/mm: Checked W+X mappings: passed, no W+X pages found.
</span></span><span class=line><span class=cl><span class=o>[</span>    9.961949<span class=o>]</span> Run /sbin/init as init process
</span></span><span class=line><span class=cl><span class=o>[</span>    9.962048<span class=o>]</span>   with arguments:
</span></span><span class=line><span class=cl><span class=o>[</span>    9.962118<span class=o>]</span>     /sbin/init
</span></span><span class=line><span class=cl><span class=o>[</span>    9.962203<span class=o>]</span>     nokaslr
</span></span><span class=line><span class=cl><span class=o>[</span>    9.962266<span class=o>]</span>   with environment:
</span></span><span class=line><span class=cl><span class=o>[</span>    9.962422<span class=o>]</span>     <span class=nv>HOME</span><span class=o>=</span>/
</span></span><span class=line><span class=cl><span class=o>[</span>    9.962492<span class=o>]</span>     <span class=nv>TERM</span><span class=o>=</span>linux
</span></span><span class=line><span class=cl><span class=o>[</span>minroot<span class=o>]</span> $
</span></span></code></pre></div><p>We&rsquo;ve successfully reached the infinite echoing loop. Although our init process is not doing anything practically useful, it demonstrates how the kernel passes the torch to user space. In front of the init process is the vast and intriguing universe of user space.</p><p>I&rsquo;ll end this post with a question: What will happen if the init process exits/aborts?</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2020-05-22</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>linux</a>,&nbsp;<a href=/tags/rootfs/>rootfs</a>,&nbsp;<a href=/tags/init/>init</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/a-terraform-module-to-list-google-cloud-service-agents/ class=prev rel=prev title="A Terraform Module to List Google Cloud Service Agents"><i class="fas fa-angle-left fa-fw"></i>A Terraform Module to List Google Cloud Service Agents</a>
<a href=/posts/home-server-setup/ class=next rel=next title="Setting Up a Home Server">Setting Up a Home Server<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.113.0">Hugo</a>&nbsp;|&nbsp;Theme - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.3.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer">yuankun</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:10},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"comment",lightTheme:"github-light",repo:"yuankunzhang/blog"}}}</script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript src=/js/utterances.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZXQSK4ST20")</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-ZXQSK4ST20" async></script></div></body></html>